<p><strong>* SW 정의 (컴퓨터프로그램 + 데이터 + 관련문서)</strong></p>
<ul>
<li>컴퓨터 하드웨어 : 계산과 놀리연산만 수행하는 단순기계</li>
<li>알고리즘 : 문제를 계산과 비교의 순차적 수행을 통해 해결하는 방법</li>
<li>컴퓨터 프로그램 : 알고리즘을 컴퓨터가 이해할 수 있는 언어로 표현 한 것</li>
</ul>
<p><strong>* SW의 본질</strong>
: 자동화된 문제 해결책(솔루션), 지식과 경험을 코딩한 지식재산
 -&gt; SW는 복제하여 나누고 재사용 가능하며, 점진적으로 개선하고 누적하여 성능을 추가할 수 있음(Mash up)</p>
<p>  ** =&gt; Software is Algrithmic Intelligence 
     알고리즘으로 지능적 행동을 컴퓨터에 구현**</p>
<p><strong>* SW 중심사회</strong> : 소프트웨어가 혁신, 성장, 가치창출의 중심이 되고 개인, 기업, 국가의 경쟁력을 좌우하는 사회</p>
<hr />
<p><strong>* 컴퓨팅사고</strong> : 컴퓨터 상에서 문제풀이</p>
<ul>
<li>컴퓨터가 효과적으로 수행하도록 문제를 정의하고 그에 대한 답을 기술하는 것이 포함된 사고 과정 일체
 (데이터분석, 추상화, 패턴 찾기, 모델구축, 알고리즘 개발, 
  데이터 수집, 문제 분해)</li>
</ul>
<p>[컴퓨터는 알고리즘이 하라는 대로 computaion 한 것, 이를 인지, 이해, 사고, 의사결정 계확 수립, 창작 등의 용어로 의인화 함]</p>
<ul>
<li>1980년 파퍼트 교수 처음으로 컴퓨팅사고라는 용어 사용</li>
<li>2006년 지넷 윙 컴퓨터사고 논문이 ACM 저널에 게재<pre><code>          ↳ 컴퓨팅 사고는 모든 사람들에게 필요한 근본적인 기술이 될것
               읽기, 쓰기, 셈하기와 함께 생활에 필수적인 역량이 될 것</code></pre></li>
</ul>
<p><strong>* 컴퓨팅 사고의 4가지 중요개념</strong></p>
<ul>
<li>분해 / 추상화 / 패턴인식 / 알고리즘 설계 =&gt; 프로그래밍(코딩)</li>
</ul>
<p><strong>* 컴퓨팅 사고의 필요성</strong></p>
<ul>
<li>인터넷과 스마트폰을 통해 전달되는 정보의 양이 기하급수적으로 증가</li>
<li>가존에 정리된 이론과 존재하는 지식을 답습하는 방식만으로는 한계</li>
<li>다양하고 복잡한 문제해결을 위해 컴퓨팅 사고 능력 필요
=&gt; 컴퓨팅 사고를 기반으로 한 SW의 이해가 필요</li>
</ul>
<p><strong>* 수요에 비해 인재가 부족</strong>
<strong>* 컴퓨팅 사고 학습은 선택이 아닌 필수</strong></p>
<ul>
<li><p>컴퓨터를 사용하여 다양한 분야에서 많은 발경과 성과가 이루어지고 있음</p>
</li>
<li><p>공한 뿐만 아닌 인문, 사회, 예술 등 모든 분야에서 컴퓨팅 사고를 통해 최상의 결과를 얻을 수 있음</p>
</li>
<li><p>컴퓨터가 어떻게 프로그래밍 되어 작업을 수행하는지 이해하게 되면 더욱 효율적으로 우리의 문제를 해결할 수 있음</p>
<p> <strong>=&gt; 4차산업 사회에서 경쟁력 있게 살아가려면 컴퓨터를 이용하여 크고 작은 문제들을 해결해야 함</strong></p>
</li>
</ul>
<p><strong>* 컴퓨터의 구성(하드웨어 + 소프트웨어)</strong></p>
<ul>
<li><p>하드웨어 : 컴퓨터를 구성하는 물리적 장치</p>
<pre><code>             (CPU, 메모리, 모니터, 키보드, 마우스, 프린터 등) </code></pre><p>-&gt; 중앙처리장치, 주기억장치, 보조기억장치, 입.출력장치 등으로 구성</p>
</li>
<li><p>소프트웨어 : 컴퓨터 프로그램과 관련된 문서들</p>
<pre><code>                 (운영체제, 한글, 게임, 동영상 플레이어, 그림판, 메신저 등)</code></pre><p>-&gt; 윈도우, 안드로이드 등과 같은 시스템 소프트웨어와 응용소프트웨어 </p>
<pre><code>등이 있음</code></pre></li>
</ul>
<hr />
<p><strong>* 프로그램 언어</strong>
: 컴퓨터의 프로그램을 작성하기 위해 고안된 언어, 사람과 컴퓨터 사이에 
  존재하는 커뮤니케이션 수단
  (컴퓨터와 소통하기 위해 프로그램밍 언어를 사용)
  (컴퓨터 내의 모든 데이터는 이진수로 표현됨)</p>
<p><strong>* 언어의 분류</strong>
고급언어(HLL) : 인간에게 보다 친근(python, java, c 등)
저급언어(LLL) : 컴퓨터에게 보다 친근(기계어, 어셈블리어)</p>
<p><strong>* 고급언어의 장점</strong></p>
<ul>
<li>하드웨어의 동작에 대해 자세히 알 필요 없음</li>
<li>하드웨어 독립적인 프로그램 작성 가능</li>
<li>개발과 유지보수가 쉬움</li>
</ul>
<hr />
<p><strong>* 문제</strong>
:  문제해결을 위해서는 문제에 대한 올바른 해석과 그에 따른 
  올바른 답을 찾는 것이 중요
: 노력한 시간 대비 효과적인 방안으로 문제를 해결하는 것이 좋음</p>
<p><strong>* 문제해결능력</strong>
: 창의적이고 논리적인 사고를 바탕응로 문제의 원인을 찾아 새로운 대안을 마련해 능동적이고 적극적으로 해결하는 능력</p>
<p><strong>* 문제해결도구</strong>
: 사고력, 문제처리능력, 컴퓨팅사고력 </p>
<p><strong>* 문제해결방안</strong></p>
<ul>
<li><p>일반적 문제해결 
: 정형화된 개념 학습, 체득원리를 문제에 응용, 반복성/지속성 있는 부분파악해 동일한 방법으로 해결, 당연한 사실로 간주되는 정보를 비판적으로 다시 사고, 다양한 관점에서 문제해결의 실마리를 찾음
(폴리아의 4단계 : 문제이해 - 계획 - 실행 - 반성) </p>
</li>
<li><p>창의적 문제해결
: 상상력에 기반한 창의적 문제해결(획일화된 방법이 아닌 새로운 관점에서 접근)</p>
</li>
<li><p>열린사고를 통한 문제해결
: 상상의 나래를 통해 해결할 수도 있는 문제들 포함, 문제의 해답이 여러 개일 경우도 있음, 정해진 해답이 없는 경우도 있음
(당연시 되는 사실에 대해 다른 가능성을 열어두는 태도, 열린 사고를 활용하면 창의적 사고의 폭이 넓어짐)</p>
</li>
</ul>
<p><strong>* 일반적 문제해결 단계</strong> 
  : 문제인식 - 원인분석 - 해결안 개발 - 실행 및 평가 - 피드백</p>
<p><strong>* 컴퓨팅사고를 활용한 문제해결</strong></p>
<ul>
<li><p>일상 속 현실 문제들을 컴퓨터를 이용하여 해결하기 위한 방법</p>
</li>
<li><p>문제의 분석, 분해, 패턴인식, 추상화, 알고리즘을 활용
(컴퓨팅사고의 핵심요소)</p>
</li>
<li><p>문제해결을 위해 창의적이고 논리적인 접근이 필요</p>
</li>
<li><p>컴퓨터를 이용한 문제해결로 효율적이고 정확한 해결책 도출 및 
유사문제에도 쉽게 적용가능</p>
</li>
<li><p>컴퓨팅 사고를 활용한 문제해결 단계
: 문제 - (컴퓨팅사고 전 단계 : 문제분석 - 데이터 수집과 표현) </p>
<ul>
<li>(컴퓨팅사고 단계 : 분해, 추상화, 패턴인식, 알고리즘) - 평가 - 코딩 - 피드백</li>
</ul>
</li>
</ul>
<ol>
<li><p>문제분석 : 문제의 핵심을 정확히 분석, 해결방안을 떠올릴 수 있는 바탕을 마련하는 것 </p>
</li>
<li><p>데이터 수집과 표현 : 문제 해결과 관련된 정보들을 컴퓨터로 수집, 데이터를 적절한 그래프, 차트, 영상 등의 형태로 표현</p>
</li>
<li><p>분해/패턴인식 단계</p>
</li>
</ol>
<ul>
<li>분해 : 복잡한 문제를 보다 쉽게 다룰 수 있도록 여러 개의 작은 문제들로 쪼개어 분해</li>
<li>패턴인식 : 문제로부터 유사성과 패턴 발견, 문제 내에서의 패턴, 경향, 규칙성 등을 관찰하여 인식</li>
</ul>
<ol start="4">
<li>추상화/알고리즘 단계</li>
</ol>
<ul>
<li>추상화 : 문제에서 불필요한 부분을 제거하고 꼭 필요한 것만을 분리해내는 과정, 복잡한 문제를 단순화, 핵심적 개념에 초첨을 맞춰 일반적 원리를 찾아냄</li>
<li>알고리즘 : 문제를 해결하기 위한 일련의 절차나 방법, 순서도, 의사코드 등의 형태로 표현</li>
</ul>
<ol start="5">
<li>평가 </li>
</ol>
<ul>
<li>알고리즘의 정확성, 해답의 적절성, 효율성 등을 최종 점검</li>
<li>평가 완료 후 알고리즘을 기반한 코딩으로 이어짐</li>
<li>최종적으로 컴퓨터를 작동해 원하는 결과 도출</li>
</ul>
<p><strong>* 분해</strong> 
  : 복잡한 문제를 좀 더 작고 처리가 가능한 작은 문제들로 나누어서 
    해결하는 방법</p>
<p><strong>* 분해를 이용한 문제해결 방안</strong></p>
<ul>
<li>분할 : 복잡한 문제를 어떻게 작은 문제로 나눌 것인가, 문제의 원인을 찾고 각 원인을 해결할 수 있는 작은 문제들을 도출</li>
<li>결합 : 작은 문제들의 답을 모아 주어진 문제의 해결책을 만드는 과정</li>
</ul>
<p><strong>* 병렬처리(Parallel processing)</strong> : 분해를 통해 작게 나누어진 문제들을 처리하는 방법 중 하나, 분해된 여러 개의 문제를 동시에 수행</p>
<ul>
<li>복수의 처리를 병렬시키거나 동시에 처리하는 방법
(※ 순차처리 : 순차또는 연속적으로 두가지 이상의 처리를 하는 형태)</li>
</ul>
<p><strong>=&gt; 데이터, 처리과정, 문제 등 모든 것들에 분할이라는 개념을 적용</strong></p>
<p><strong>* 문제에 대해 문제를 해결하기 위한 또 다른(일반적으로 쉽게 생각되는) 문제들을 정의할 수 있음</strong></p>
<ul>
<li>분할한 문제들의 해를 조합해 문제의 해를 구함</li>
<li>분할된 문제들은 일반적으로 문제보다는 규모가 작거나 쉽게 해결할 수 있는 문제들임</li>
<li>그러나 분할된 문제에 쉽게 해결할 수 없는 문제가 여전히 있다면 그 문제를 이보다 작은 문제로 더 이상 분해할 필요가 없을 때까지 계속 분해할 수 있음</li>
<li>문제의 해는 일련의 연산들로 구성된 알고리즘인데, 이들 각 연산은 덧셈, 뺄셈 등 단순한 문제들의 해</li>
</ul>
<p><strong>* 패턴인식</strong> : 문제의 유사성 또는 패턴을 탐색하여 효율적으로 문제를 해결</p>
<p><strong>* 추상화(문제에 대한 일반적인 모델을 생성하는 것)</strong></p>
<ul>
<li>문제에서 불필요한 부분을 제거하고 꼭 필요한 것만을 분리해내는 과정</li>
<li>복잡한 문제를 단순화</li>
<li>핵심적 개념에 초첨을 맞춰 일반적 원리를 찾아냄</li>
</ul>
<p>** =&gt; 핵심요소를 파악하고 복잡함을 단순화하여 문제를 해결함**</p>
<p><strong>* 개념 형성의 일반화 과정</strong>
문제(데이터) → 패턴인식 → 일정한 경향 / 반복적 규칙 / 공통적 속성 → 추상화 → 불필요한 사항 제거 / 핵심 요소 추출 / 일반화 </p>
<p><strong>* 추상화의 필요성</strong></p>
<ul>
<li><p>문제가 무엇인지 명확히 
: 일반적 특징에서 불필요한 모든 세부사항 제거
  -&gt; 명확한 모델 형성에 도움</p>
</li>
<li><p>문제에 대한 개념을 형성 
: 문제를 해결하는 일반적인 아이디어를 얻을 수 있음</p>
</li>
<li><p>세부적인 사항은 서로 다를지라도 추상화를 통해 핵심 요소만 추출하면 동일한 문제로 모델링 되기도 함 =&gt; 일반화</p>
</li>
</ul>
<p><strong>* 동일한 문제라도 관점에 따라 서로 다름</strong>
ex1) 커피머신 - 관리자입장(머신관리를 위해 내부구조 이해) / 사용자입장(머신 사용법만이해) 
ex2) 지도 -  교통혼잡 파악 / 토지사용용도 파악 / 상세지형 파악</p>
<hr />
<p><strong>* 알고리즘</strong> : 어떤 일을 수행하기 위한 일련의 유한한 순서화된 절차</p>
<ul>
<li>컴퓨팅 사고과정인 분할, 패턴인식, 추상화를 통해 얻은 결과를 바탕으로 문제의 단계적인 해결 방법을 최종적으로 기술한(나열한) 것
=&gt; 컴퓨팅 사고력의 최종목표 : 잘 설계된 알고리즘</li>
<li>알고리즘의 절차를 수행하는 주체는 굳이 컴퓨터일 필요는 없음
(적절한 자동화 장치 또는 사람이 수행해도 무관)</li>
<li>알고리즘은 자연어, 순서도, 의사코드로 표현될 수 있음</li>
</ul>
<p><strong>* 알고리즘은 일련의 순서에 의해 실행되어 문제를 해결할 수 있는 유한개의 instruction 또는 statement 들의 집합</strong></p>
<ul>
<li>instruction : 컴퓨터 명력(기본연산 및 알고리즘의 절차0</li>
<li>statement : 명령문(instruuction과 동일한 의미, 주로 HLL 언어에서 하나의 명령구문을 지칭)</li>
<li><ul>
<li>순서도** : 사전 지정한 심볼을 화살표로 연결하여 알고리즘을 기술하는 방법
<img alt="" src="https://velog.velcdn.com/images/hyeonji13/post/9fb89351-7c05-4876-8c93-013f862c18e8/image.png" /></li>
</ul>
</li>
</ul>
<p><img alt="" src="https://velog.velcdn.com/images/hyeonji13/post/6bae2bd0-e83d-48c7-818a-9e4885759210/image.png" /></p>
<p><strong>* 알고리즘이 갖추어야 할 조건</strong></p>
<ul>
<li>순차성 : 알고리즘은 올바른 순서대로 진행되어야 문제가 해결됨</li>
<li>명확성 : 각 명령어의 의미는 모호하지 않고 명확해야 함</li>
<li>유효성 : 각 명령어들은 실행 가능한 연산이어야 함</li>
<li>유한성 : 한정된 수의 명령어가 실행된 후에는 반드시 종료되어야 함</li>
<li>효율성 : 어려가지 방법 중에서 가장 효율적인 방법으로 문제들을 해결해야 함</li>
</ul>
<p><strong>* 알고리즘의 기술방법</strong>
[자연어(Natural language)] 문제해결 절차를 단계별로 자연스럽게 말로써 기술하는 방법</p>
<p>[순서도(Flowchart)] 알고리즘을 표준화된 기호 및 도형으로 도식화하여 데이터의 흐름과 수행되는 절차들을 표현하는 방법</p>
<ul>
<li>3가지 기본제어 구조</li>
</ul>
<ol>
<li>순차구조</li>
<li>선택구조</li>
<li>반복구조
<img alt="" src="https://velog.velcdn.com/images/hyeonji13/post/f18f3f37-c8f5-40ca-bc06-2526a25de5c0/image.png" /></li>
</ol>
<ul>
<li>컴퓨터 실행을 위한 알고리즘의 구성요소(instruction들의 기능)
[arithmetic] 덧셈, 뺄셈 등 연산 기능
[assignment] 데이터 값을 메모리에 저장하거나 다른 장소로 이동 기능
[input and output] 두 데이터 값의 비교 기능
[conditional] 비교 결과에 따른 선택적 실행 기능
[iteration] 특저한 instruction들의 반복 실행 기능</li>
</ul>
<p>[의사코드(Pseudo-code)] 프로그래밍 언어 코드를 흉내 내어 자유롭게 알고리즘을 기술하는 방법
(문법에 구애 받지 않고 사람이 이해할 수 있는 수준)
<img alt="" src="https://velog.velcdn.com/images/hyeonji13/post/85252a1e-72ea-4754-8330-1c11a0788039/image.png" /></p>
<p><strong>* 알고리즘의 예시</strong></p>
<p>알고리즘 평가의 종류</p>
<ul>
<li><p>성능 평가(Performance Evaluation)
: 알고리즘 또는 제품을 개발할 때 여러 시점에서 평가를 수행하는 것, 
평가 -&gt; 수정 작업을 반복, 
제품 출시 전 평가에 해당, 
컴퓨터 알고리즘의 주요 평가요소는 정확성, 계산 시간과 메모리 사용량</p>
</li>
<li><p>성능 측정(Performance Measurement)
: 제품 출시 후 성능을 일정 기간에 걸쳐 검사하는 것,
휴대폰, 윈도우 시스템들이 계속 업데이트되는 것은 성능 측정이 결과임</p>
</li>
</ul>
<p><strong>* 알고리즘의 성능평가</strong>
: 입력이 매우 큰 경우 최악의 경우를 가정하여 측정되며 
  이러한 상황에서 최고의 성능을 발휘할 수 있도록 설계되어야 함</p>
<p><strong>* 특징</strong> </p>
<ul>
<li>최악의 경우 실행시간을 추상화한 것</li>
<li>모든 상수 값을 생략하여 실제 수행할 컴퓨터에 영향을 받지 않고 알고리즘의 성능을 평가할 수 있음</li>
<li>최악의 경우 연산수가 0.5N2+10N+100이라면
dominating term의 상수 값을 생략하고 O(N²)이라고 표현함</li>
<li>어떤 알고리즘의 실행시간이 O(g(n)) 이라면, 알고리즘의 시간복잡도는 O(g(n))이다.</li>
</ul>
<hr />
<p>1 자동화
•컴퓨팅사고를 통해 정리한 문제해결 과정을 컴퓨터에서
작동하도록 프로그래밍하는 과정
2 파이썬(Python)
•배우기 쉽고, 생산성이 뛰어나며 다양한 분야에 활용되는
프로그래밍 언어
•대화형 모드와 스크립트 모드가 있음
•인공지능, 빅데이터 등의 프로그래밍을 하려면
추가적인 라이브러리 설치가 필요함</p>